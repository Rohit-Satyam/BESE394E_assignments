---
title: "Reproducing JCI Paper"
author:
  - name: Rohit Satyam
    orcid: 0000-0002-9311-4992
    email: rohit.satyam@kaust.edu.sa
    affiliations:
      - name: King Abdullah University of Science & Technology, SA
        address: 4700, KAUST
        city: Thuwal
        state: Jeedah
        postal-code: 23955
        
clean: false
date: "`r format(Sys.Date(), '%B %d, %Y')`"

vignette: >
 %\VignetteIndexEntry{Reproducing JCI Paper}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}  
 %\VignetteDepends{BiocStyle}
 %\VignetteAuthor{Rohit Satyam}

output: 
    BiocStyle::html_document:
      toc: true
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, cache = T,cache.lazy = FALSE)
options(knitr.duplicate.label = "allow")
```

## Bulk RNASeq Data analysis

The raw bulk RNASeq data for 34 samples was obtained from [GSE198256](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE198256) and was uniformly processed using my in-house RNASeq analysis pipeline called [RNAGrinder](https://github.com/Rohit-Satyam/RNAgrinder) (v1.0.1). We ran MultiQC on STAR output to get the sense of data quality post alignment. We found that the data was stranded and that reads came from Forward Strand. We will therefore take 2nd column of the STAR Gene count matrices.

```{r}
library(dplyr)
library(DESeq2)
library(NOISeq)
```

```{r}
setwd('~/data/coursework2024/week1/jcpaper/results')
file_paths <- list.files(path = ".",pattern = "_ReadsPerGene.out.tab")

# Initialize an empty list to store the data
files<-t(plyr::ldply(lapply(file_paths, function(x){
  read.table(x, skip=4)[,3]
})))

colnames(files) <- gsub("_ReadsPerGene.out.tab","",file_paths)
rownames(files) <- read.table(file_paths[1], skip=4)[,1]

## reading metadata
meta <- read.csv("SraRunTable.txt", header = T)
meta <- meta[,c(1,14)]
meta$disease_state <- mgsub::mgsub(meta$disease_state,c("Covid19: Acute infection","Covid19: Recovery 3Mo","Covid19: Recovery 6Mo"), c("Covid19AI","Covid19_3Mo","Covid19_6Mo"))

```

For making NOIseq ExpressionSet object, one can use the code given below to get the coordinates and GC% but since different database have different chromosome indexing (0-based or 1-based) this might not be ideal.

```{r, eval=FALSE}
## Using BioMart
library(biomaRt)
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")

#View(listAttributes(ensembl))
## Get the coordinates of genes to get length and GC content 
attributes <- c("ensembl_gene_id", "chromosome_name", "start_position","end_position","percentage_gene_gc_content")
gene_info <- getBM(attributes = attributes, 
                   filters = "ensembl_gene_id", 
                   values = GeneStructureTools::removeVersion(rownames(files)[1:4]), 
                   mart = ensembl)
```

Let's try to procure the same information using our own GTF and FASTA file that were used for mapping the reads. This will enable us to use this code for any other non-model organism for which such information can not be obtained from BioMart.

```{r, eval=TRUE}
library(GenomicRanges)
library(rtracklayer)
library(Rsamtools)

# Load GTF file
GTFfile <- "../../resource/gencode.v45.primary_assembly.annotation.gtf"
GTF <- import.gff(GTFfile, format="gtf", genome="GRCh38", feature.type="gene")

# Reduce to merge overlapping features and simplify data structure
gene_ids <- mcols(GTF)$gene_id
gene_biotypes <- mcols(GTF)$gene_type

## reading the FASTA reference
FASTAfile = "../../resource/GRCh38.primary_assembly.genome.fa"
FASTA <- FaFile(FASTAfile)
seqs <- getSeq(FASTA, GTF)  # Use original GTF ranges to ensure correct sequence retrieval
gc_counts <- letterFrequency(seqs, letters = c("G", "C"), as.prob = FALSE)
lengths <- width(GTF)
gc_content <- rowSums(gc_counts) / lengths

# Extract necessary information (gene ID and gene biotype)
gene_info <- data.frame(
  gene_id = gene_ids,
  gene_biotype = gene_biotypes,
  gc=gc_content,
  length=lengths,starts=start(GTF),ends=end(GTF),
  chr=seqnames(GTF),stringsAsFactors = FALSE)
saveRDS(gene_info, "gene_info.rds")
```

Now, once we have all the attributes of all the genes, let's compare the if the order of the genes in `gene_info` is same as the counts files we read.

```{r, eval=FALSE}
table(rownames(files)==gene_info$gene_id)
rownames(meta)<-meta$Run
meta <- meta[colnames(files),]
rownames(gene_info)<-gene_info$gene_id
## making expressionSet object to run noiseq functions
data_NOISEQ <- readData(data = files,
                        length=setNames(gene_info$length, gene_info$gene_id),
                        gc=setNames(gene_info$gc, gene_info$gene_id),
                        biotype=setNames(gene_info$gene_biotype, gene_info$gene_id),
                        chromosome = gene_info[,c("chr","starts","ends")],
                        factors = meta)

save(data_NOISEQ,files,gene_info,file="GSE198256_step1.Rda")
```

```{r}
## Loading all the 
load("GSE198256_step1.Rda")
myexplodata <- dat(data_NOISEQ, type = "biodetection")
explo.plot(myexplodata, plottype = "persample")

par(mfrow = c(1, 2))
explo.plot(myexplodata, samples = c(1, 2), toplot = "protein_coding", plottype = "comparison")


mycountsbio = dat(data_NOISEQ, factor = NULL, type = "countsbio")
explo.plot(mycountsbio, toplot = 1, samples = 1, plottype = "boxplot")

mysaturation = dat(data_NOISEQ, k = 0, ndepth = 7, type = "saturation")
explo.plot(mysaturation, toplot = 1, samples = 1:2, yleftlim = NULL, yrightlim = NULL)
explo.plot(mysaturation, toplot = "protein_coding", samples = 1:4)

explo.plot(mycountsbio, toplot = "protein_coding", samples = NULL, plottype = "boxplot")

explo.plot(mycountsbio, toplot = 1, samples = NULL, plottype = "barplot")

mylengthbias = dat(data_NOISEQ, factor = "disease_state", type = "lengthbias")
explo.plot(mylengthbias, samples = NULL, toplot = "global")

myGCbias = dat(data_NOISEQ, factor = "disease_state", type = "GCbias")
explo.plot(myGCbias, samples = NULL, toplot = "global")

#mycd = dat(data_NOISEQ, type = "cd", norm = FALSE, refColumn = 1)
#explo.plot(mycd,samples = 1:12)

myPCA = dat(data_NOISEQ, type = "PCA")
## To match paper's label
myPCA@dat$factors$disease_state <- mgsub::mgsub(myPCA@dat$factors$disease_state,unique(myPCA@dat$factors$disease_state),c("Late Recovery","Early Recovery","Acute","Control"))
explo.plot(myPCA, factor = "disease_state")

## Since we have more than two condition, the linew below will throw an error
#QCreport(data_NOISEQ, samples = NULL, factor = "disease_state", norm = FALSE)
```

### Normalization and differential expression with DESeq

NOISeq offers different flavors of normalization such as RPKM, UQ and TMM. The code to do this is given below.

```{r, message=FALSE, warning=FALSE, eval=F}

## Normalisation approached provided by NOISeq includes RPKM, Upper Quartile and TMM (Trimmed Mean of M)
myRPKM = rpkm(assayData(data_NOISEQ)$exprs, long = data_NOISEQ@featureData@data$Length, k = 0, lc = 1)
myUQUA = uqua(assayData(data_NOISEQ)$exprs, long = data_NOISEQ@featureData@data$Length, lc = 0.5, k = 0)
myTMM = tmm(assayData(data_NOISEQ)$exprs, long = 1000, lc = 0)
```

But since we wanna use DESeq2 we will use the raw counts and perform gene filtering before carrying out differential analysis.

```{r}
## Make DESeqDataSet object
GSE198256_DESeq2 <- DESeqDataSetFromMatrix(countData = data_NOISEQ@assayData$exprs,
                                           colData = data_NOISEQ@phenoData@data,
                                           design = ~ disease_state)
GSE198256_DESeq2$disease_state<-relevel(GSE198256_DESeq2$disease_state,ref = "Healthy")

# Filtering genes with low counts
dim(GSE198256_DESeq2)

## Adding gene names and metadata
rowData(GSE198256_DESeq2) <- data_NOISEQ@featureData@data
## Adding Gene symbols
mcols(GSE198256_DESeq2)$names <- GTF$gene_name[match(GTF$gene_id,rownames(data_NOISEQ@featureData@data) )]

## Finding the smallest group size
smallestGroupSize <- min(table(GSE198256_DESeq2$disease_state))
smallestGroupSize
# remove genes that do not have counts >=10 in atleast 6 sample
keep <- rowSums(counts(GSE198256_DESeq2) >= 10) >= smallestGroupSize
GSE198256_DESeq2_F <- GSE198256_DESeq2[keep,] # 14,055 x 34
dim(GSE198256_DESeq2_F)
GSE198256_DESeq2_F$labels <- as.character(GSE198256_DESeq2_F$disease_state)
GSE198256_DESeq2_F$labels <- mgsub::mgsub(GSE198256_DESeq2_F$labels,unique(GSE198256_DESeq2_F$labels),c("Late Recovery","Early Recovery","Acute","Control"))
## making PCA using VST normalised data
vsd <- vst(GSE198256_DESeq2_F, blind=TRUE,fitType = "parametric")
plotPCA(vsd, intgroup=c("labels"), returnData=FALSE)+ggplot2::theme_minimal()+
    ggplot2::stat_ellipse()
## Differential expression analysis
GSE198256_DESeq2_F<- DESeq(GSE198256_DESeq2_F)

#results(dds, contrast=c("condition","treated","untreated"))
ctrl.vs.acute <- results(GSE198256_DESeq2_F, contrast=c("disease_state","Covid19AI","Healthy"))
ctrl.vs.early <- results(GSE198256_DESeq2_F, contrast=c("disease_state","Covid19_3Mo","Healthy"))
ctrl.vs.late <- results(GSE198256_DESeq2_F, contrast=c("disease_state","Covid19_6Mo","Healthy"))
```

#### Q1. Do we use all the genes?

Filtering genes before performing differential expression analysis is a critical step in RNASeq pipeline due to following reasons:

-   **Low Expression**: Genes that are expressed at very low levels across all samples often reflect background noise rather than true biological signals. These low counts can lead to high variability and unreliable statistical tests.

-   **Increasing Statistical Power**: By removing genes that are unlikely to be informative (e.g., those with very low expression), you can reduce the multiple testing burden and increase the statistical power to detect true differences in the remaining genes.

-   **Speeding Up Analysis**: Filtering out a significant number of genes from the analysis can dramatically decrease the computational time required for downstream statistical testing and analysis.

-   **Resource Management**: This is particularly important when dealing with large datasets like TCGA Cancer dataset or limited computational resources.

#### Q2. How do we select which ones?

There are several ways to skin a cat so you can choose one of the following criteria:

-   **Expression Level**: Genes with average counts below a certain threshold across all samples are often filtered out (See below that we take expression value threshold as `10`).
-   **Presence/Absence**: Genes need to be expressed in a minimum number of samples or sample groups (See below where we choose the minimum no. of sample based on the smallest subgroup).
-   **Coefficient of Variation:** Genes with very high variability relative to their mean expression might be excluded. This method is less common but one can filter genes which vary greatly across say technical or biological replicates.

# Understanding the DE results

# plot MA

```{r}
resultsNames(GSE198256_DESeq2_F)
ctrl.vs.acute <- lfcShrink(GSE198256_DESeq2_F, coef = 4)
ctrl.vs.early <- lfcShrink(GSE198256_DESeq2_F, coef=2)
ctrl.vs.late <- lfcShrink(GSE198256_DESeq2_F, coef=3)

## table(rownames(ctrl.vs.acute)==rownames(rowData(GSE198256_DESeq2_F)))
ctrl.vs.acute$symbol <- rowData(GSE198256_DESeq2_F)$names
ctrl.vs.early$symbol <- rowData(GSE198256_DESeq2_F)$names
ctrl.vs.late$symbol <- rowData(GSE198256_DESeq2_F)$names

  
plotMA(ctrl.vs.acute, ylim=c(-2,2))
plotMA(ctrl.vs.early, ylim=c(-2,2))
plotMA(ctrl.vs.late, ylim=c(-2,2))

## Filter DEGs
#filter DEGs: |FC| > 2 and FDR < 0.05 i.e. LFC value of 1
gtools::logratio2foldchange(1)
ctrl.vs.acute.sig <- subset(as.data.frame(ctrl.vs.acute) %>%tibble::rownames_to_column("Geneid"), padj <= 0.05 & abs(log2FoldChange)>1)
ctrl.vs.early.sig <- subset(as.data.frame(ctrl.vs.early)%>%tibble::rownames_to_column("Geneid"), padj <= 0.05 & abs(log2FoldChange)>1)
ctrl.vs.late.sig <- subset(as.data.frame(ctrl.vs.late)%>%tibble::rownames_to_column("Geneid"), padj <= 0.05 & abs(log2FoldChange)>1)

res <- list("Ctrl vs Acute"=ctrl.vs.acute.sig,
            "Ctrl vs Early Recov"=ctrl.vs.early.sig,
            "Ctrl vs Late Recov"=ctrl.vs.late.sig)
writexl::write_xlsx(res,"jci_DEGs.xlsx")
# Why to shrink: it looks at the largest fold changes that are not due 
# to low counts and uses these to inform a prior distribution. 
# So the large fold changes from genes with lots of statistical information are 
# not shrunk, while the imprecise fold changes are shrunk. This allows you to 
# compare all estimated LFC across experiments, for example, which is not really
# feasible without the use of a prior. 
# Michael Love https://support.bioconductor.org/p/77461/
```

**Interpretation:** The MA plot provides a quick visual assessment of the differential expression analysis. It helps to identify genes that are significantly differentially expressed (blue points) and to see how the fold changes distribute across genes with different expression levels. The data points' spread along the y-axis (M) often narrows as you move to the right along the x-axis (A) because the relative change in expression (fold change) is generally more stable for genes with higher expression levels, reflecting the decreased variance associated with more abundant transcripts.

As expected, we can see that there are very few DEGs when Late Recovery monocytes samples were compared to control samples

### Comparison between *Brauns et. al.* and our analysis.

Severe COVID-19 significantly disrupts the myeloid immune cells during the infection, with effects lingering after recovery. The [@Brauns2022] paper revealed that during the acute phase, patients with severe COVID-19 had monocytes with reduced cytokine production. Although the monocyte function mostly recovered after the illness, individuals who with Acute COVID showed heightened responses to certain immune triggers. Here we tried to reproduce their RNASeq data analysis in order to gauge to what extent we can reproduce the results. We use a slightly different pipeline and thresholds as tabulated below

**Difference in methodologies:**

| Steps               | Bruns et al                                                                                         | Our Analysis                                                                           |
|------------------|----------------------------|--------------------------|
| Adapter Trimming    | Trimmomatic-0.36 Truseq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36 HEADCROP:4 | --detect_adapter_for_pe --qualified_quality_phred 30 --length_required 75 --correction |
| Ribodepletion       | NA                                                                                                  | Used Ribodetector                                                                      |
| Alignment           | STAR 2.5.3a Default                                                                                 | STAR 2.7.11b using ENCODE guidelines                                                   |
| Feature Counts      | HTSeq-0.9.1 with “--nonunique all”                                                                  | STAR GeneCount with HTSeq “--nonunique none” (default)                                 |
| Gene Filtering      | Gene counts \> 20; no. of samples \> 1                                                              | Gene counts \> 10; no. of samples \> 6                                                 |
| Enrichment analysis | BubbleGUM                                                                                           | clusterProfiler                                                                        |

: (\#tab:table) Differences between our RNASeq analysis pipeline and JCI paper's.

**Comparing the results**

The PCA showed similar segregation of samples as reported by paper (see the plots below). We can see a clear separation between samples from acute COVID-19 patients and healthy controls. Samples from patients in the early recovery stage clustered distinctly, while those in the late recovery stage were embedded within the control group. PCA **Plot A** was plotted without using NOISeq, **Plot B** was plotted using filtered VST normalized counts and **Plot C** is from the paper. 


```{r}
library(png)
library(grid)
library(gridExtra)
img3 <-  rasterGrob(as.raster(readPNG("images/Screenshot from 2024-04-27 18-07-36.png")), interpolate = FALSE)
img1 <-  rasterGrob(as.raster(readPNG("images/PCA2.png")), interpolate = FALSE)
img2 <-  rasterGrob(as.raster(readPNG("images/PCA3.png")), interpolate = FALSE)
ggpubr::ggarrange(img1,img2,img3, ncol = 2, nrow = 2,labels = "AUTO")
```

The authors used DESeq2 to perform the differential expression analysis. So using DESeq2 and performed DGEA for three comparisons: acute infection (AI) vs healthy (H), and the two stages of recovery (3Mo and 6Mo) vs healthy. We kept the genes that passed the thresholds mentioned in the article, FDR < 0.05 and |FC| > 2 i.e LFC of 1.

```{r}
library(schoolmath)
ctrl.vs.acute.sig$status <- ifelse(is.negative(ctrl.vs.acute.sig$log2FoldChange),"down","up")
table(ctrl.vs.acute.sig$status)
ctrl.vs.early.sig$status <- ifelse(is.negative(ctrl.vs.early.sig$log2FoldChange),"down","up")
table(ctrl.vs.early.sig$status)
ctrl.vs.late.sig$status <- ifelse(is.negative(ctrl.vs.late.sig$log2FoldChange),"down","up")
table(ctrl.vs.late.sig$status)
```

The patients with Acute COVID showed highest number of DEGs (`571 down-regulated and 350 up-regulated`) followed by Early Recovery patients (`317 down-regulated 378 up-regulated`). This was oppose to what paper observed i.e. more DEGs in Early recovery and less in Acute Infection patients. The Late recovery patients showed very few DEGs (` 26 down 11 up`) which is in corcordance with the paper.

As authors reported, we also found down-regulation of genes related to key immune pathways, such as antigenic presentation, innate immune responses and MAPK and NF-κB signalling (JUNB, ATF3, NFkB2) in monocytes from patients suffering from Acute COVID-19. In addition, we also didn't observe the upregulation of immunosuppressive genes such as ARG1, IL-10, or IDO1 in Acute Patients which is in concordance with what the paper has reported.

Like authors mentioned, for Ctrl vs Early recovery samples we also observed upregulation of genes encoding chemokines, along with important intracellular immunomodulatory proteins and transcription factors (PPARG, FOSL1, MAFB, MAFF, FOXO3) except ATF4.

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)
library(GeneStructureTools)
a <- enrichGO(gene = unique(removeVersion(ctrl.vs.acute.sig[ctrl.vs.acute.sig$status=="up",]$Geneid)),
OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
ont = "BP",
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
qvalueCutoff = 0.1,
readable = TRUE)

b <- enrichGO(gene = unique(removeVersion(ctrl.vs.acute.sig[ctrl.vs.acute.sig$status=="down",]$Geneid)),
OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
ont = "BP",
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
qvalueCutoff = 0.1,
readable = TRUE)
 
#dotplot
plt1 <- dotplot(a, showCategory = 10,
font.size = 10,
title = "Acute.vs.Healthy (Upreg)")

plt2 <- dotplot(b, showCategory = 10,
font.size = 10,
title = "Acute.vs.Healthy (Downreg)")
ggpubr::ggarrange(plt1,plt2,labels = "AUTO")

```
ORA gave many over-represented biological terms for Acute DEGs but nothing significant for Eary Recovery Samples.
```{r}
a <- enrichGO(gene = unique(removeVersion(ctrl.vs.early.sig[ctrl.vs.early.sig$status=="up",]$Geneid)),
OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
ont = "BP",
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
qvalueCutoff = 0.1,
readable = TRUE)

b <- enrichGO(gene = unique(removeVersion(ctrl.vs.early.sig[ctrl.vs.early.sig$status=="down",]$Geneid)),
OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
ont = "BP",
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
qvalueCutoff = 0.1,
readable = TRUE)
 
#dotplot
# plt1 <- dotplot(a, showCategory = 10,
# font.size = 10,
# title = "Early Recov.vs.Healthy (Upreg)")
## No-enrichment was observed for upregulated genes
plt2 <- dotplot(b, showCategory = 10,
font.size = 10,
title = "Early Recov.vs.Healthy (Downreg)")
ggpubr::ggarrange(plt2,labels = "AUTO")
```

### GSEA

On performing GSEA analysis however, we got similar pathways to be enriched as shown by authors in the paper such as mitochondrial gene expression being enriched profoundly Acute vs. Healthy (AvH) (padj=8.684443e-06) relative to Early recovery cohort (EvH) (padj=0.013; not shown in figure). Instead of term "viral gene expression" we have related term "viral life cycle" in EvH (padj=5.931676e-05) but have smaller p-value in  AvH ("response to virus" (padj=0.04712597)).
```{r}
rank.wt <- -log10(ctrl.vs.acute$pvalue) * sign(ctrl.vs.acute$log2FoldChange)
names(rank.wt) <- removeVersion(rownames(ctrl.vs.acute))
rank.wt <- sort(rank.wt,decreasing = T)

a <- gseGO(geneList=,rank.wt,
ont ="BP",
keyType = "ENSEMBL",
minGSSize = 3,
maxGSSize = 800,
pvalueCutoff = 0.05,
verbose = TRUE,
OrgDb = org.Hs.eg.db,
pAdjustMethod = "BH")

plt1 <- dotplot(a, showCategory = 10,
        font.size = 10,
        title = "Acute.vs.Healthy")

rank.wt <- -log10(ctrl.vs.early$pvalue) * sign(ctrl.vs.early$log2FoldChange)
names(rank.wt) <- removeVersion(rownames(ctrl.vs.early))
rank.wt <- sort(rank.wt,decreasing = T)

b <- gseGO(geneList=,rank.wt,
ont ="BP",
keyType = "ENSEMBL",
minGSSize = 3,
maxGSSize = 800,
pvalueCutoff = 0.05,
verbose = TRUE,
OrgDb = org.Hs.eg.db,
pAdjustMethod = "BH")

plt2 <- dotplot(b, showCategory = 10,
        font.size = 10,
        title = "Early Recov.vs.Healthy")

ggpubr::ggarrange(plt1,plt2,labels = "AUTO")
```
Results from paper are shown below:

![](jci.insight.154183.f7.jpg)

## Conclusion

In summary, we were able to reproduce several major outcomes of the JCI paper but there was discord in number of DEGs when Acute and Early Recovery RNASeq data was compared to control. This could be due to number of reasons enlisted in \@ref(tab:label). This should not be surprising because there are several ways to skin a cat and the outcome will differ from time to time based on which instruments were used.

# Session {-}

```{r}
sessionInfo()
```